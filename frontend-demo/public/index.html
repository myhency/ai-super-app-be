<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Topic SSE Chat Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .chat-manager {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .chat-header h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .worker-status {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .active-count {
            color: #ffeb3b;
            font-weight: bold;
        }

        .chat-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Topic Sidebar */
        .topic-sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .topic-list-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .topic-list-header h2 {
            font-size: 1.1rem;
            color: #333;
        }

        .create-topic-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .create-topic-btn:hover {
            background: #45a049;
        }

        .topic-items {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .topic-item {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .topic-item:hover {
            background: #f0f0f0;
            border-color: #ccc;
        }

        .topic-item.selected {
            background: #e3f2fd;
            border-color: #2196F3;
        }

        .topic-item.active {
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.3);
        }

        .topic-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .topic-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-icon {
            font-size: 1.2rem;
        }

        .topic-name {
            font-weight: bold;
            color: #333;
        }

        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
        }

        .delete-btn:hover {
            background: #d32f2f;
        }

        .topic-info {
            font-size: 0.8rem;
            color: #666;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.25rem;
        }

        .activity-indicator {
            margin-top: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 4px;
            font-size: 0.8rem;
            color: #4CAF50;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pulse {
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        /* Chat Main */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .chat-room {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .chat-room-header {
            padding: 1rem;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
        }

        .topic-info h2 {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 0.25rem;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #666;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .active-badge {
            background: #4CAF50;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: #f9f9f9;
        }

        .welcome-message {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .welcome-message h3 {
            margin-bottom: 1rem;
            color: #333;
        }

        .example-messages {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .example-message {
            background: white;
            border: 1px solid #ddd;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .example-message:hover {
            background: #f0f0f0;
            border-color: #2196F3;
        }

        .message {
            margin-bottom: 1rem;
            padding: 1rem;
            border-radius: 12px;
            max-width: 80%;
        }

        .message.user {
            background: #2196F3;
            color: white;
            margin-left: auto;
        }

        .message.assistant {
            background: white;
            border: 1px solid #e0e0e0;
        }

        .message.error {
            background: #ffebee;
            border: 1px solid #f44336;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }

        .role-badge {
            font-weight: bold;
        }

        .timestamp {
            opacity: 0.7;
        }

        .streaming-indicator .dots {
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .message-content {
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .message-input-form {
            padding: 1rem;
            border-top: 1px solid #e0e0e0;
            background: white;
        }

        .input-container {
            display: flex;
            gap: 0.5rem;
        }

        .message-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #ddd;
            border-radius: 24px;
            font-size: 1rem;
            outline: none;
        }

        .message-input:focus {
            border-color: #2196F3;
        }

        .send-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 24px;
            cursor: pointer;
            font-size: 1rem;
            min-width: 80px;
        }

        .send-button:hover:not(:disabled) {
            background: #1976D2;
        }

        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .input-hints {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            color: #666;
            text-align: center;
        }

        .background-notification {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid #4CAF50;
            border-radius: 8px;
            padding: 0.75rem;
            margin: 1rem;
            font-size: 0.9rem;
            color: #2E7D32;
        }

        /* Background Activity */
        .background-activity {
            background: white;
            border-top: 1px solid #e0e0e0;
            padding: 1rem 2rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .background-activity h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: #333;
        }

        .background-topics {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .background-topic {
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .background-topic:hover {
            background: #e0e0e0;
            border-color: #2196F3;
        }

        .background-topic.status-connected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .status-indicator {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .no-topic {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #666;
        }

        .no-topic button {
            margin-top: 1rem;
            background: #2196F3;
            color: white;
            border: none;
            padding: 1rem 2rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }

        .loading-spinner {
            animation: spin 1s infinite linear;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Token Settings */
        .token-settings {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        
        .token-input-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }
        
        .token-input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: monospace;
            font-size: 0.8rem;
        }
        
        .token-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .token-input:focus {
            outline: none;
            border-color: #ffeb3b;
        }
        
        .token-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }
        
        .token-btn:hover {
            background: #45a049;
        }
        
        .token-btn.clear {
            background: #f44336;
        }
        
        .token-btn.clear:hover {
            background: #d32f2f;
        }
        
        .token-status {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
        }
        
        .token-status.valid {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .token-status.invalid {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .token-status.empty {
            background: rgba(255, 235, 59, 0.2);
            color: #FBC02D;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="loading">Ïï±ÏùÑ Î°úÎî© Ï§ë...</div>
    </div>

    <!-- React Í∞úÎ∞úÏö© CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Î™®Îì† Ïª¥Ìè¨ÎÑåÌä∏Î•º Ïù∏ÎùºÏù∏ÏúºÎ°ú Î°úÎìú -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // ULID ÏÉùÏÑ± Ìï®Ïàò (ULID Ïä§Ìéô Ï§ÄÏàò)
        function generateULID() {
          // Crockford's Base32 Ïù∏ÏΩîÎî© Î¨∏ÏûêÏÖã (I, L, O, U Ï†úÏô∏)
          const ENCODING = '0123456789ABCDEFGHJKMNPQRSTVWXYZ';
          
          // ÌòÑÏû¨ ÏãúÍ∞Ñ (Unix Epoch Í∏∞Ï§Ä Î∞ÄÎ¶¨Ï¥à)
          const timestamp = Date.now();
          
          // 48ÎπÑÌä∏ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑÎ•º Crockford's Base32Î°ú Ïù∏ÏΩîÎî© (10ÏûêÎ¶¨)
          let timeStr = '';
          let time = timestamp;
          for (let i = 0; i < 10; i++) {
            timeStr = ENCODING[time % 32] + timeStr;
            time = Math.floor(time / 32);
          }
          
          // 80ÎπÑÌä∏ ÎûúÎç§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (crypto API ÏÇ¨Ïö©)
          let randomStr = '';
          if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
            // 10Î∞îÏù¥Ìä∏ (80ÎπÑÌä∏) ÎûúÎç§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            const randomBytes = new Uint8Array(10);
            crypto.getRandomValues(randomBytes);
            
            // Î∞îÏù¥Ìä∏Î•º Crockford's Base32Î°ú Ïù∏ÏΩîÎî© (16ÏûêÎ¶¨)
            let randomBits = '';
            for (let i = 0; i < randomBytes.length; i++) {
              randomBits += randomBytes[i].toString(2).padStart(8, '0');
            }
            
            // 5ÎπÑÌä∏Ïî© ÏûòÎùºÏÑú Base32 Ïù∏ÏΩîÎî©
            for (let i = 0; i < 80; i += 5) {
              const chunk = randomBits.substr(i, 5);
              const index = parseInt(chunk, 2);
              randomStr += ENCODING[index];
            }
          } else {
            // crypto APIÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Math.random() ÏÇ¨Ïö© (fallback)
            for (let i = 0; i < 16; i++) {
              randomStr += ENCODING[Math.floor(Math.random() * 32)];
            }
          }
          
          // 26ÏûêÎ¶¨ ULID Î∞òÌôò (10ÏûêÎ¶¨ ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ + 16ÏûêÎ¶¨ ÎûúÎç§)
          return timeStr + randomStr;
        }
        
        // JWT ÌÜ†ÌÅ∞ Í¥ÄÎ¶¨ Hook
        function useAuthToken() {
          const [token, setToken] = useState(() => {
            return localStorage.getItem('jwt_token') || '';
          });
          
          const [tokenStatus, setTokenStatus] = useState('empty');
          
          useEffect(() => {
            validateToken(token);
          }, [token]);
          
          const validateToken = (tokenValue) => {
            if (!tokenValue) {
              setTokenStatus('empty');
              return;
            }
            
            try {
              // JWT Íµ¨Ï°∞ Í≤ÄÏ¶ù (Ìó§Îçî.ÌéòÏù¥Î°úÎìú.ÏãúÍ∑∏ÎãàÏ≤ò)
              const parts = tokenValue.split('.');
              if (parts.length !== 3) {
                setTokenStatus('invalid');
                return;
              }
              
              // ÌéòÏù¥Î°úÎìú ÎîîÏΩîÎî© ÏãúÎèÑ
              const payload = JSON.parse(atob(parts[1]));
              
              // ÎßåÎ£å ÏãúÍ∞Ñ Ï≤¥ÌÅ¨
              if (payload.exp && payload.exp * 1000 < Date.now()) {
                setTokenStatus('expired');
                return;
              }
              
              setTokenStatus('valid');
            } catch (error) {
              console.error('ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù Ïã§Ìå®:', error);
              setTokenStatus('invalid');
            }
          };
          
          const updateToken = (newToken) => {
            setToken(newToken);
            if (newToken) {
              localStorage.setItem('jwt_token', newToken);
            } else {
              localStorage.removeItem('jwt_token');
            }
          };
          
          const clearToken = () => {
            setToken('');
            localStorage.removeItem('jwt_token');
          };
          
          const getAuthHeaders = () => {
            if (token && tokenStatus === 'valid') {
              return {
                'Authorization': `Bearer ${token}`
              };
            }
            return {};
          };
          
          return {
            token,
            tokenStatus,
            updateToken,
            clearToken,
            getAuthHeaders,
            isTokenValid: tokenStatus === 'valid'
          };
        }
        
        // useSSEWorker Hook
        function useSSEWorker() {
          const [worker, setWorker] = useState(null);
          const [activeTopics, setActiveTopics] = useState(new Set());
          const [connectionStatus, setConnectionStatus] = useState({});
          const messageHandlers = useRef(new Map());
          const [isWorkerReady, setIsWorkerReady] = useState(false);
          
          useEffect(() => {
            console.log('SSE Worker Ï¥àÍ∏∞Ìôî ÏãúÏûë');
            
            const sseWorker = new Worker('/sse-worker.js');
            
            sseWorker.onmessage = (e) => {
              const { type, topicId, data, error, timestamp } = e.data;
              console.log(`Worker Î©îÏãúÏßÄ ÏàòÏã†: ${type}`, { topicId, data });
              
              switch(type) {
                case 'CONNECTION_OPENED':
                  setConnectionStatus(prev => ({
                    ...prev,
                    [topicId]: 'connected'
                  }));
                  break;
                  
                case 'MESSAGE':
                case 'CHUNK':
                  const handler = messageHandlers.current.get(topicId);
                  if (handler) {
                    handler(data);
                  } else {
                    console.warn(`Ìï∏Îì§Îü¨Í∞Ä ÏóÜÎäî topic: ${topicId}`);
                  }
                  break;
                  
                case 'COMPLETE':
                  console.log(`Ïä§Ìä∏Î¶º ÏôÑÎ£å: ${topicId} at ${timestamp}`);
                  
                  showCompletionNotification(topicId);
                  
                  setActiveTopics(prev => {
                    const newSet = new Set(prev);
                    newSet.delete(topicId);
                    return newSet;
                  });
                  
                  setConnectionStatus(prev => ({
                    ...prev,
                    [topicId]: 'completed'
                  }));
                  
                  messageHandlers.current.delete(topicId);
                  break;
                  
                case 'CONNECTION_CLOSED':
                  setConnectionStatus(prev => ({
                    ...prev,
                    [topicId]: 'closed'
                  }));
                  break;
                  
                case 'RECONNECTING':
                  setConnectionStatus(prev => ({
                    ...prev,
                    [topicId]: 'reconnecting'
                  }));
                  break;
                  
                case 'ERROR':
                  console.error(`SSE ÏóêÎü¨: ${topicId}`, error);
                  setConnectionStatus(prev => ({
                    ...prev,
                    [topicId]: 'error'
                  }));
                  
                  const errorHandler = messageHandlers.current.get(`${topicId}_error`);
                  if (errorHandler) {
                    errorHandler(error);
                  }
                  break;
                  
                case 'WORKER_ERROR':
                  console.error('Worker ÏóêÎü¨:', error);
                  break;
                  
                default:
                  console.log(`Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Î©îÏãúÏßÄ ÌÉÄÏûÖ: ${type}`);
              }
            };
            
            sseWorker.onerror = (error) => {
              console.error('Worker ÏóêÎü¨:', error);
              setIsWorkerReady(false);
            };
            
            setWorker(sseWorker);
            setIsWorkerReady(true);
            
            requestNotificationPermission();
            
            return () => {
              console.log('Worker Ï†ïÎ¶¨ ÏãúÏûë');
              if (sseWorker) {
                sseWorker.postMessage({ type: 'CLOSE_ALL' });
                sseWorker.terminate();
              }
              setIsWorkerReady(false);
            };
          }, []);
          
          const requestNotificationPermission = async () => {
            if ('Notification' in window && Notification.permission === 'default') {
              try {
                const permission = await Notification.requestPermission();
                console.log('ÏïåÎ¶º Í∂åÌïú:', permission);
              } catch (error) {
                console.error('ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìå®:', error);
              }
            }
          };
          
          const showCompletionNotification = (topicId) => {
            if ('Notification' in window && Notification.permission === 'granted') {
              const notification = new Notification('AI ÏùëÎãµ ÏôÑÎ£å', {
                body: `ÎåÄÌôî ${topicId}Ïùò ÏùëÎãµÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§. ÌÅ¥Î¶≠ÌïòÏó¨ ÌôïÏù∏ÌïòÏÑ∏Ïöî.`,
                icon: '/chat-icon.png',
                tag: topicId,
                requireInteraction: true
              });
              
              notification.onclick = () => {
                window.focus();
                window.location.hash = `#/chat/${topicId}`;
                notification.close();
              };
              
              setTimeout(() => {
                notification.close();
              }, 5000);
            }
          };
          
          const startSSE = useCallback((topicId, onMessage, onError, authHeaders = {}) => {
            if (!worker || !isWorkerReady) {
              console.warn('WorkerÍ∞Ä Ï§ÄÎπÑÎêòÏßÄ ÏïäÏùå');
              return false;
            }
            
            if (activeTopics.has(topicId)) {
              console.log(`Topic ${topicId} Ïù¥ÎØ∏ ÌôúÏÑ±ÌôîÎê®`);
              return false;
            }
            
            console.log(`SSE ÏãúÏûë: ${topicId}`);
            
            if (onMessage) {
              messageHandlers.current.set(topicId, onMessage);
            }
            
            if (onError) {
              messageHandlers.current.set(`${topicId}_error`, onError);
            }
            
            const url = `http://localhost:8080/v1/chat?topicId=${topicId}`;
            worker.postMessage({
              type: 'START_SSE',
              topicId,
              url,
              headers: authHeaders
            });
            
            setActiveTopics(prev => new Set([...prev, topicId]));
            setConnectionStatus(prev => ({
              ...prev,
              [topicId]: 'connecting'
            }));
            
            return true;
          }, [worker, isWorkerReady, activeTopics]);
          
          const stopSSE = useCallback((topicId) => {
            if (!worker) return;
            
            console.log(`SSE Ï§ëÏßÄ: ${topicId}`);
            
            worker.postMessage({
              type: 'CLOSE_SSE',
              topicId
            });
            
            setActiveTopics(prev => {
              const newSet = new Set(prev);
              newSet.delete(topicId);
              return newSet;
            });
            
            setConnectionStatus(prev => ({
              ...prev,
              [topicId]: 'stopped'
            }));
            
            messageHandlers.current.delete(topicId);
            messageHandlers.current.delete(`${topicId}_error`);
          }, [worker]);
          
          const stopAllSSE = useCallback(() => {
            if (!worker) return;
            
            console.log('Î™®Îì† SSE Ïó∞Í≤∞ Ï§ëÏßÄ');
            
            worker.postMessage({ type: 'CLOSE_ALL' });
            
            setActiveTopics(new Set());
            setConnectionStatus({});
            messageHandlers.current.clear();
          }, [worker]);
          
          const getTopicStatus = useCallback((topicId) => {
            return connectionStatus[topicId] || 'disconnected';
          }, [connectionStatus]);
          
          return { 
            startSSE, 
            stopSSE,
            stopAllSSE,
            activeTopics: Array.from(activeTopics),
            connectionStatus,
            getTopicStatus,
            isWorkerReady,
            worker
          };
        }
        
        // TopicList Ïª¥Ìè¨ÎÑåÌä∏
        function TopicList({ 
          topics, 
          currentTopicId, 
          activeTopics, 
          connectionStatus,
          onSelectTopic, 
          onCreateTopic, 
          onDeleteTopic 
        }) {
          
          const getStatusIcon = (topicId) => {
            const status = connectionStatus[topicId];
            const isActive = activeTopics.includes(topicId);
            
            switch(status) {
              case 'connecting': return 'üîÑ';
              case 'connected': return 'üü¢';
              case 'reconnecting': return 'üü°';
              case 'error': return 'üî¥';
              case 'completed': return '‚úÖ';
              case 'closed':
              case 'stopped': return '‚ö´';
              default: return isActive ? 'üü¢' : '‚ö™';
            }
          };
          
          const getStatusText = (topicId) => {
            const status = connectionStatus[topicId];
            const isActive = activeTopics.includes(topicId);
            
            if (isActive) {
              switch(status) {
                case 'connecting': return 'Ïó∞Í≤∞ Ï§ë...';
                case 'connected': return 'ÏùëÎãµ ÎåÄÍ∏∞';
                case 'reconnecting': return 'Ïû¨Ïó∞Í≤∞ Ï§ë...';
                case 'error': return 'ÏóêÎü¨ Î∞úÏÉù';
                case 'completed': return 'ÏùëÎãµ ÏôÑÎ£å';
                default: return 'ÌôúÏÑ±';
              }
            }
            
            return status === 'completed' ? 'ÏôÑÎ£åÎê®' : 'ÎåÄÍ∏∞';
          };

          return React.createElement('div', { className: 'topic-list' },
            React.createElement('div', { className: 'topic-list-header' },
              React.createElement('h2', null, 'ÎåÄÌôî Î™©Î°ù'),
              React.createElement('button', {
                className: 'create-topic-btn',
                onClick: onCreateTopic,
                title: 'ÏÉà ÎåÄÌôî ÏãúÏûë'
              }, '+ ÏÉà ÎåÄÌôî')
            ),
            
            React.createElement('div', { className: 'topic-items' },
              topics.map(topic => {
                const isSelected = topic.id === currentTopicId;
                const isActive = activeTopics.includes(topic.id);
                
                return React.createElement('div', {
                  key: topic.id,
                  className: `topic-item ${isSelected ? 'selected' : ''} ${isActive ? 'active' : ''}`,
                  onClick: () => onSelectTopic(topic.id)
                },
                  React.createElement('div', { className: 'topic-header' },
                    React.createElement('div', { className: 'topic-status' },
                      React.createElement('span', { className: 'status-icon' }, getStatusIcon(topic.id)),
                      React.createElement('span', { className: 'topic-name' }, topic.name)
                    ),
                    React.createElement('button', {
                      className: 'delete-btn',
                      onClick: (e) => {
                        e.stopPropagation();
                        onDeleteTopic(topic.id);
                      },
                      title: 'ÎåÄÌôî ÏÇ≠Ï†ú'
                    }, '√ó')
                  ),
                  
                  React.createElement('div', { className: 'topic-info' },
                    React.createElement('div', { className: 'topic-id' }, `ID: ${topic.id.slice(-8)}`),
                    React.createElement('div', { className: 'topic-status-text' }, getStatusText(topic.id)),
                    React.createElement('div', { className: 'topic-time' }, new Date(topic.createdAt).toLocaleTimeString())
                  ),
                  
                  isActive && React.createElement('div', { className: 'activity-indicator' },
                    React.createElement('div', { className: 'pulse' }),
                    'Î∞±Í∑∏ÎùºÏö¥Îìú Ïã§Ìñâ Ï§ë'
                  )
                );
              })
            ),
            
            topics.length === 0 && React.createElement('div', { className: 'empty-topics' },
              React.createElement('p', null, 'ÏïÑÏßÅ ÎåÄÌôîÍ∞Ä ÏóÜÏäµÎãàÎã§.'),
              React.createElement('button', { onClick: onCreateTopic }, 'Ï≤´ Î≤àÏß∏ ÎåÄÌôî ÏãúÏûëÌïòÍ∏∞')
            ),
            
            React.createElement('div', { className: 'topic-list-footer' },
              React.createElement('div', { className: 'summary' },
                `Ï¥ù ${topics.length}Í∞ú ÎåÄÌôî`,
                activeTopics.length > 0 && React.createElement('span', { className: 'active-summary' }, 
                  `(${activeTopics.length}Í∞ú ÌôúÏÑ±)`
                )
              )
            )
          );
        }
        
        // ChatRoom Ïª¥Ìè¨ÎÑåÌä∏
        function ChatRoom({ 
          topicId, 
          messages, 
          onSendMessage, 
          connectionStatus,
          isActive 
        }) {
          const [inputValue, setInputValue] = useState('');
          const [isLoading, setIsLoading] = useState(false);
          const messagesEndRef = useRef(null);
          const inputRef = useRef(null);
          
          useEffect(() => {
            messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
          }, [messages]);
          
          useEffect(() => {
            inputRef.current?.focus();
          }, [topicId]);
          
          const handleSubmit = async (e) => {
            e.preventDefault();
            
            const content = inputValue.trim();
            if (!content) return;
            
            setIsLoading(true);
            setInputValue('');
            
            try {
              await onSendMessage(content);
            } catch (error) {
              console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
            } finally {
              setIsLoading(false);
            }
          };
          
          const getConnectionStatusText = () => {
            switch(connectionStatus) {
              case 'connecting': return 'Ïó∞Í≤∞ Ï§ë...';
              case 'connected': return 'Ïó∞Í≤∞Îê®';
              case 'reconnecting': return 'Ïû¨Ïó∞Í≤∞ Ï§ë...';
              case 'error': return 'Ïó∞Í≤∞ Ïò§Î•ò';
              case 'completed': return 'ÏùëÎãµ ÏôÑÎ£å';
              case 'closed':
              case 'stopped': return 'Ïó∞Í≤∞ Ï¢ÖÎ£å';
              default: return 'ÎåÄÍ∏∞ Ï§ë';
            }
          };
          
          const getConnectionStatusColor = () => {
            switch(connectionStatus) {
              case 'connected': return '#4CAF50';
              case 'connecting':
              case 'reconnecting': return '#FF9800';
              case 'error': return '#F44336';
              case 'completed': return '#2196F3';
              default: return '#9E9E9E';
            }
          };
          
          const formatTimestamp = (timestamp) => {
            return new Date(timestamp).toLocaleTimeString();
          };
          
          const getExampleMessages = () => {
            return [
              "ÏïàÎÖïÌïòÏÑ∏Ïöî! Ïñ¥ÎñªÍ≤å ÎèÑÏôÄÎìúÎ¶¥ÍπåÏöî?",
              "Ïò§Îäò ÎÇ†Ïî®Îäî Ïñ¥Îñ§Í∞ÄÏöî?", 
              "JavaScriptÏóê ÎåÄÌï¥ ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî",
              "Ïû¨ÎØ∏ÏûàÎäî ÎÜçÎã¥ ÌïòÎÇò Ìï¥Ï£ºÏÑ∏Ïöî",
              "React HookÏùò Ïû•Ï†êÏùÄ Î¨¥ÏóáÏù∏Í∞ÄÏöî?"
            ];
          };

          return React.createElement('div', { className: 'chat-room' },
            React.createElement('div', { className: 'chat-room-header' },
              React.createElement('div', { className: 'topic-info' },
                React.createElement('h2', null, `ÎåÄÌôî: ${topicId.slice(-8)}`),
                React.createElement('div', { className: 'connection-status' },
                  React.createElement('span', {
                    className: 'status-dot',
                    style: { backgroundColor: getConnectionStatusColor() }
                  }),
                  getConnectionStatusText(),
                  isActive && React.createElement('span', { className: 'active-badge' }, 'Ïã§Ìñâ Ï§ë')
                )
              ),
              React.createElement('div', { className: 'chat-stats' },
                React.createElement('span', null, `Î©îÏãúÏßÄ: ${messages.length}`)
              )
            ),
            
            React.createElement('div', { className: 'messages-container' },
              messages.length === 0 && React.createElement('div', { className: 'welcome-message' },
                React.createElement('h3', null, 'ÏÉàÎ°úÏö¥ ÎåÄÌôîÎ•º ÏãúÏûëÌïòÏÑ∏Ïöî!'),
                React.createElement('p', null, 'ÏïÑÎûò ÏòàÏãú Î©îÏãúÏßÄÎ•º ÌÅ¥Î¶≠ÌïòÍ±∞ÎÇò ÏßÅÏ†ë ÏûÖÎ†•Ìï¥Î≥¥ÏÑ∏Ïöî:'),
                React.createElement('div', { className: 'example-messages' },
                  getExampleMessages().map((example, index) =>
                    React.createElement('button', {
                      key: index,
                      className: 'example-message',
                      onClick: () => setInputValue(example),
                      disabled: isLoading
                    }, example)
                  )
                )
              ),
              
              messages.map(message =>
                React.createElement('div', {
                  key: message.id,
                  className: `message ${message.role} ${message.error ? 'error' : ''}`
                },
                  React.createElement('div', { className: 'message-header' },
                    React.createElement('span', { className: 'role-badge' },
                      message.role === 'user' ? 'üë§ ÏÇ¨Ïö©Ïûê' : 'ü§ñ AI'
                    ),
                    React.createElement('span', { className: 'timestamp' },
                      formatTimestamp(message.timestamp)
                    ),
                    !message.completed && React.createElement('span', { className: 'streaming-indicator' },
                      React.createElement('span', { className: 'dots' }, '...')
                    )
                  ),
                  
                  React.createElement('div', { className: 'message-content' }, message.content),
                  
                  message.error && React.createElement('div', { className: 'error-info' },
                    '‚ö†Ô∏è Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.'
                  )
                )
              ),
              
              React.createElement('div', { ref: messagesEndRef })
            ),
            
            React.createElement('form', { className: 'message-input-form', onSubmit: handleSubmit },
              React.createElement('div', { className: 'input-container' },
                React.createElement('input', {
                  ref: inputRef,
                  type: 'text',
                  value: inputValue,
                  onChange: (e) => setInputValue(e.target.value),
                  placeholder: isLoading 
                    ? "Î©îÏãúÏßÄ Ï†ÑÏÜ° Ï§ë..." 
                    : connectionStatus === 'error'
                    ? "Ïó∞Í≤∞ Ïò§Î•ò - Ïû¨ÏãúÎèÑÌïòÏÑ∏Ïöî"
                    : "Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî...",
                  disabled: isLoading,
                  className: 'message-input'
                }),
                
                React.createElement('button', {
                  type: 'submit',
                  disabled: isLoading || !inputValue.trim(),
                  className: 'send-button'
                }, isLoading 
                  ? React.createElement('span', { className: 'loading-spinner' }, '‚è≥')
                  : 'Ï†ÑÏÜ°'
                )
              ),
              
              React.createElement('div', { className: 'input-hints' },
                React.createElement('span', { className: 'hint' },
                  'EnterÎ•º ÎàåÎü¨ Ï†ÑÏÜ° ‚Ä¢ ' + (isActive ? ' Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÏùëÎãµ ÏàòÏã† Ï§ë' : ' ÎåÄÍ∏∞ ÏÉÅÌÉú')
                )
              )
            ),
            
            isActive && connectionStatus === 'connected' && React.createElement('div', { className: 'background-notification' },
              'üîÑ Ïù¥ ÎåÄÌôîÎäî Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§ÌñâÎê©ÎãàÎã§. Îã§Î•∏ ÌéòÏù¥ÏßÄÎ°ú Ïù¥ÎèôÌï¥ÎèÑ ÏùëÎãµ ÏôÑÎ£å Ïãú ÏïåÎ¶ºÏùÑ Î∞õÏùÑ Ïàò ÏûàÏäµÎãàÎã§.'
            )
          );
        }
        
        // TokenSettings Ïª¥Ìè¨ÎÑåÌä∏
        function TokenSettings() {
          const { token, tokenStatus, updateToken, clearToken, isTokenValid } = useAuthToken();
          const [inputToken, setInputToken] = useState('');
          const [showToken, setShowToken] = useState(false);
          
          const handleSaveToken = () => {
            updateToken(inputToken.trim());
            setInputToken('');
          };
          
          const handleClearToken = () => {
            clearToken();
            setInputToken('');
          };
          
          const getStatusMessage = () => {
            switch(tokenStatus) {
              case 'valid': return '‚úÖ Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞';
              case 'invalid': return '‚ùå ÏûòÎ™ªÎêú ÌÜ†ÌÅ∞ ÌòïÏãù';
              case 'expired': return '‚è∞ ÎßåÎ£åÎêú ÌÜ†ÌÅ∞';
              case 'empty': return '‚ö†Ô∏è ÌÜ†ÌÅ∞Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§';
              default: return '‚ùì Ïïå Ïàò ÏóÜÎäî ÏÉÅÌÉú';
            }
          };
          
          return React.createElement('div', { className: 'token-settings' },
            React.createElement('div', null, 'üîê JWT Ïù∏Ï¶ù ÌÜ†ÌÅ∞'),
            
            React.createElement('div', { className: 'token-input-container' },
              React.createElement('input', {
                type: showToken ? 'text' : 'password',
                value: inputToken || token,
                onChange: (e) => setInputToken(e.target.value),
                placeholder: token ? 'ÏÉà ÌÜ†ÌÅ∞ ÏûÖÎ†•...' : 'JWT ÌÜ†ÌÅ∞ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî',
                className: 'token-input'
              }),
              
              React.createElement('button', {
                type: 'button',
                onClick: () => setShowToken(!showToken),
                className: 'token-btn',
                title: showToken ? 'ÌÜ†ÌÅ∞ Ïà®Í∏∞Í∏∞' : 'ÌÜ†ÌÅ∞ Î≥¥Í∏∞'
              }, showToken ? 'üëÅÔ∏è' : 'üôà'),
              
              React.createElement('button', {
                type: 'button',
                onClick: handleSaveToken,
                disabled: !inputToken.trim(),
                className: 'token-btn'
              }, 'Ï†ÄÏû•'),
              
              token && React.createElement('button', {
                type: 'button',
                onClick: handleClearToken,
                className: 'token-btn clear'
              }, 'ÏÇ≠Ï†ú')
            ),
            
            React.createElement('div', {
              className: `token-status ${tokenStatus}`
            }, getStatusMessage())
          );
        }
        
        // ChatManager Ïª¥Ìè¨ÎÑåÌä∏
        function ChatManager() {
          const { 
            startSSE, 
            stopSSE, 
            activeTopics, 
            connectionStatus, 
            getTopicStatus,
            isWorkerReady 
          } = useSSEWorker();
          
          const { getAuthHeaders, isTokenValid } = useAuthToken();
          
          const [currentTopicId, setCurrentTopicId] = useState(null);
          const [topics, setTopics] = useState([]);
          const [chatHistory, setChatHistory] = useState({});
          
          const createNewTopic = () => {
            const newTopicId = generateULID();
            
            setTopics(prev => [...prev, {
              id: newTopicId,
              name: `ÎåÄÌôî ${topics.length + 1}`,
              createdAt: new Date().toISOString(),
              status: 'created'
            }]);
            
            setChatHistory(prev => ({
              ...prev,
              [newTopicId]: []
            }));
            
            setCurrentTopicId(newTopicId);
            
            return newTopicId;
          };
          
          const selectTopic = (topicId) => {
            setCurrentTopicId(topicId);
          };
          
          const sendMessage = async (topicId, content) => {
            if (!isTokenValid) {
              alert('‚ö†Ô∏è JWT ÌÜ†ÌÅ∞ÏùÑ Î®ºÏ†Ä ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî. ÏÉÅÎã®Ïùò ÌÜ†ÌÅ∞ ÏÑ§Ï†ïÏóêÏÑú Ïú†Ìö®Ìïú ÌÜ†ÌÅ∞ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
              return;
            }
            
            // ÏÇ¨Ïö©Ïûê Î©îÏãúÏßÄ Ï∂îÍ∞Ä
            setChatHistory(prev => ({
              ...prev,
              [topicId]: [
                ...(prev[topicId] || []),
                {
                  id: Date.now(),
                  role: 'user',
                  content,
                  timestamp: new Date().toISOString(),
                  completed: true
                }
              ]
            }));
            
            // AI ÏùëÎãµ Î©îÏãúÏßÄ Ï§ÄÎπÑ
            const aiMessageId = Date.now() + 1;
            setChatHistory(prev => ({
              ...prev,
              [topicId]: [
                ...prev[topicId],
                {
                  id: aiMessageId,
                  role: 'assistant',
                  content: '',
                  timestamp: new Date().toISOString(),
                  completed: false
                }
              ]
            }));
            
            const handleStreamMessage = (data) => {
              setChatHistory(prev => ({
                ...prev,
                [topicId]: prev[topicId].map(msg => 
                  msg.id === aiMessageId 
                    ? { ...msg, content: msg.content + (data.content || data.text || JSON.stringify(data)) }
                    : msg
                )
              }));
            };
            
            const handleStreamComplete = () => {
              setChatHistory(prev => ({
                ...prev,
                [topicId]: prev[topicId].map(msg => 
                  msg.id === aiMessageId 
                    ? { ...msg, completed: true }
                    : msg
                )
              }));
            };
            
            const handleError = (error) => {
              setChatHistory(prev => ({
                ...prev,
                [topicId]: prev[topicId].map(msg => 
                  msg.id === aiMessageId 
                    ? { ...msg, content: `ÏóêÎü¨ Î∞úÏÉù: ${error}`, completed: true, error: true }
                    : msg
                )
              }));
            };
            
            // POST ÏöîÏ≤≠ÏúºÎ°ú ÏßÅÏ†ë SSE Ï≤òÎ¶¨
            await sendMessageWithSSE(topicId, content, handleStreamMessage, handleStreamComplete, handleError);
          };
          
          const sendMessageWithSSE = async (topicId, content, handleStreamMessage, handleStreamComplete, handleError) => {
            console.log(`ÏÑúÎ≤ÑÏóê Î©îÏãúÏßÄ Ï†ÑÏÜ°: ${topicId}`, content);
            
            try {
              const authHeaders = getAuthHeaders();
              
              console.log('Ïù∏Ï¶ù Ìó§Îçî:', authHeaders);
              console.log('ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ±:', isTokenValid);
              
              // Ï≤´ ÎåÄÌôîÏù∏ÏßÄ ÌôïÏù∏ (Î©îÏãúÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Ï≤´ ÎåÄÌôî)
              const isFirstMessage = !chatHistory[topicId] || chatHistory[topicId].length === 0;
              
              // ChatRequest.SendMessageRequest ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï (Ï≤´ ÎåÄÌôîÏãú topicId null)
              const requestBody = {
                userChatId: generateULID(),
                aiChatId: generateULID(),
                topicId: isFirstMessage ? null : topicId,  // Ï≤´ ÎåÄÌôîÎäî null, Ïù¥ÌõÑÎäî topicId
                parentId: null,
                previousMessages: [],
                content: content,
                contents: null
              };
              
              console.log('ÏöîÏ≤≠ Î≥∏Î¨∏:', requestBody);
              
              const response = await fetch('http://localhost:8080/v1/chat', {
                method: 'POST',
                headers: { 
                  'Content-Type': 'application/json',
                  'Accept': 'text/event-stream',
                  ...authHeaders
                },
                body: JSON.stringify(requestBody)
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              console.log('Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏÑ±Í≥µ, SSE Ïä§Ìä∏Î¶º ÏãúÏûë:', response.status);
              
              // SSE Ïä§Ìä∏Î¶º Ï≤òÎ¶¨
              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              
              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  
                  const chunk = decoder.decode(value);
                  const lines = chunk.split('\n');
                  
                  for (const line of lines) {
                    if (line.startsWith('data: ')) {
                      const data = line.slice(6);
                      if (data.trim() === '[DONE]') {
                        console.log('SSE Ïä§Ìä∏Î¶º ÏôÑÎ£å');
                        handleStreamComplete();
                        return;
                      }
                      
                      try {
                        const parsed = JSON.parse(data);
                        handleStreamMessage(parsed);
                      } catch (e) {
                        // JSONÏù¥ ÏïÑÎãå ÌÖçÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞
                        handleStreamMessage({ content: data });
                      }
                    }
                  }
                }
                
                // Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ïä§Ìä∏Î¶ºÏù¥ Ï¢ÖÎ£åÎêú Í≤ΩÏö∞
                handleStreamComplete();
                
              } finally {
                reader.releaseLock();
              }
              
            } catch (error) {
              console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
              handleError(error.message);
            }
          };
          
          const simulateServerRequest = async (topicId, content, handleStreamMessage, handleError) => {
            console.log(`ÏÑúÎ≤ÑÏóê Î©îÏãúÏßÄ Ï†ÑÏÜ°: ${topicId}`, content);
            
            try {
              const authHeaders = getAuthHeaders();
              
              console.log('Ïù∏Ï¶ù Ìó§Îçî:', authHeaders);
              console.log('ÌÜ†ÌÅ∞ Ïú†Ìö®ÏÑ±:', isTokenValid);
              
              // ChatRequest.SendMessageRequest ÌòïÏãùÏóê ÎßûÍ≤å ÏàòÏ†ï (topicId ÌïÑÎìúÎ™Ö ÏàòÏ†ï)
              const requestBody = {
                userChatId: generateULID(),
                aiChatId: generateULID(),
                topicId: topicId,
                parentId: null,
                previousMessages: [],
                content: content,
                contents: null
              };
              
              console.log('ÏöîÏ≤≠ Î≥∏Î¨∏:', requestBody);
              
              const response = await fetch('http://localhost:8080/v1/chat', {
                method: 'POST',
                headers: { 
                  'Content-Type': 'application/json',
                  'Accept': 'text/event-stream',
                  ...authHeaders
                },
                body: JSON.stringify(requestBody)
              });
              
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              
              console.log('Î©îÏãúÏßÄ Ï†ÑÏÜ° ÏÑ±Í≥µ, SSE Ïä§Ìä∏Î¶º ÏãúÏûë:', response.status);
              
              // SSE Ïä§Ìä∏Î¶º Ï≤òÎ¶¨
              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              
              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  
                  const chunk = decoder.decode(value);
                  const lines = chunk.split('\n');
                  
                  for (const line of lines) {
                    if (line.startsWith('data: ')) {
                      const data = line.slice(6);
                      if (data.trim() === '[DONE]') {
                        console.log('SSE Ïä§Ìä∏Î¶º ÏôÑÎ£å');
                        return;
                      }
                      
                      try {
                        const parsed = JSON.parse(data);
                        handleStreamMessage(parsed);
                      } catch (e) {
                        // JSONÏù¥ ÏïÑÎãå ÌÖçÏä§Ìä∏ Îç∞Ïù¥ÌÑ∞
                        handleStreamMessage({ content: data });
                      }
                    }
                  }
                }
              } finally {
                reader.releaseLock();
              }
              
            } catch (error) {
              console.error('Î©îÏãúÏßÄ Ï†ÑÏÜ° Ïã§Ìå®:', error);
              handleError(error.message);
            }
          };
          
          const deleteTopic = (topicId) => {
            stopSSE(topicId);
            
            setTopics(prev => prev.filter(topic => topic.id !== topicId));
            
            setChatHistory(prev => {
              const newHistory = { ...prev };
              delete newHistory[topicId];
              return newHistory;
            });
            
            if (currentTopicId === topicId) {
              const remainingTopics = topics.filter(topic => topic.id !== topicId);
              setCurrentTopicId(remainingTopics.length > 0 ? remainingTopics[0].id : null);
            }
          };
          
          useEffect(() => {
            if (topics.length === 0) {
              createNewTopic();
            }
          }, []);
          
          return React.createElement('div', { className: 'chat-manager' },
            React.createElement('div', { className: 'chat-header' },
              React.createElement('h1', null, 'Multi-Topic Chat with Background SSE'),
              React.createElement('div', { className: 'worker-status' },
                `Worker ÏÉÅÌÉú: ${isWorkerReady ? '‚úÖ Ï§ÄÎπÑÎê®' : '‚ùå Ï§ÄÎπÑ Ï§ë...'}`,
                activeTopics.length > 0 && React.createElement('span', { className: 'active-count' },
                  ` | ÌôúÏÑ± ÎåÄÌôî: ${activeTopics.length}Í∞ú`
                )
              ),
              React.createElement(TokenSettings)
            ),
            
            React.createElement('div', { className: 'chat-layout' },
              React.createElement('div', { className: 'topic-sidebar' },
                React.createElement(TopicList, {
                  topics,
                  currentTopicId,
                  activeTopics,
                  connectionStatus,
                  onSelectTopic: selectTopic,
                  onCreateTopic: createNewTopic,
                  onDeleteTopic: deleteTopic
                })
              ),
              
              React.createElement('div', { className: 'chat-main' },
                currentTopicId 
                  ? React.createElement(ChatRoom, {
                      topicId: currentTopicId,
                      messages: chatHistory[currentTopicId] || [],
                      onSendMessage: (content) => sendMessage(currentTopicId, content),
                      connectionStatus: getTopicStatus(currentTopicId),
                      isActive: activeTopics.includes(currentTopicId)
                    })
                  : React.createElement('div', { className: 'no-topic' },
                      React.createElement('p', null, 'ÎåÄÌôîÎ•º ÏãúÏûëÌïòÎ†§Î©¥ ÏÉà TopicÏùÑ ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.'),
                      React.createElement('button', { onClick: createNewTopic }, 'ÏÉà ÎåÄÌôî ÏãúÏûë')
                    )
              )
            ),
            
            activeTopics.length > 1 && React.createElement('div', { className: 'background-activity' },
              React.createElement('h3', null, 'Î∞±Í∑∏ÎùºÏö¥Îìú ÎåÄÌôî ÏßÑÌñâ Ï§ë:'),
              React.createElement('div', { className: 'background-topics' },
                activeTopics
                  .filter(topicId => topicId !== currentTopicId)
                  .map(topicId => {
                    const topic = topics.find(t => t.id === topicId);
                    const status = getTopicStatus(topicId);
                    return React.createElement('div', {
                      key: topicId,
                      className: `background-topic status-${status}`,
                      onClick: () => selectTopic(topicId)
                    },
                      React.createElement('span', null, topic?.name || topicId),
                      React.createElement('span', { className: 'status-indicator' }, status)
                    );
                  })
              )
            )
          );
        }
        
        function App() {
            const [error, setError] = useState(null);
            
            useEffect(() => {
                // ÏÑúÎπÑÏä§ ÏõåÏª§ Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨
                if (!window.Worker) {
                    setError('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî Web WorkerÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                    return;
                }
                
                // ÏïåÎ¶º API Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨
                if (!('Notification' in window)) {
                    console.warn('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏïåÎ¶º APIÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
                }
                
                console.log('Ïï±Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î°úÎìúÎêòÏóàÏäµÎãàÎã§.');
            }, []);
            
            if (error) {
                return (
                    <div style={{ 
                        display: 'flex', 
                        justifyContent: 'center', 
                        alignItems: 'center', 
                        height: '100vh',
                        flexDirection: 'column',
                        color: '#f44336'
                    }}>
                        <h2>Ïï± Î°úÎìú Ïò§Î•ò</h2>
                        <p>{error}</p>
                        <button onClick={() => window.location.reload()}>
                            ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®
                        </button>
                    </div>
                );
            }
            
            return React.createElement(ChatManager);
        }
        
        // Ïï± Î†åÎçîÎßÅ
        const root = ReactDOM.createRoot(document.getElementById('app'));
        root.render(React.createElement(App));
        
        // Í∏ÄÎ°úÎ≤å ÏóêÎü¨ Ìï∏Îì§ÎßÅ
        window.addEventListener('error', (e) => {
            console.error('Í∏ÄÎ°úÎ≤å ÏóêÎü¨:', e.error);
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Ï≤òÎ¶¨ÎêòÏßÄ ÏïäÏùÄ Promise Í±∞Î∂Ä:', e.reason);
        });
        
        console.log('Multi-Topic SSE Chat DemoÍ∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.');
    </script>
</body>
</html>